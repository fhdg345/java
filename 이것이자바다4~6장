★필드
필드는 객체의 고유 데이터,부품 객체,상태 정보를 저장하는 곳.
필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재
필드 선언
필드 선언은 클래스 중괄호 {} 블록 어디서든 존재 가능. 하지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다. 생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 된다,필드 선언은 변수의 선언 형태와 유사하다.타입은 필드에 저장할 데이터의 종류를 결정하고 타입에는 (byte,short,int,long,float,double,Boolean)과 참조 타입(배열,클래스,인터페이스) 모두가 올 수 있다.
필드 사용 – 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말한다. 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야한다. 그 이유는 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재x

★생성자
생성자는 new연산자로 호출되는 특별한 중괄호{}블록이다. 역할은 객체 생성시 초기화를 담당한다. 생성자는 메소드와 비슷하게 생겼지만 클래스이름으로 되어 있고 리턴 타입이 없다.
기본 생성자 – 모든 클래스는 생성자가 반드시 존재하며 하나 이상을 가질 수 있다.우리가 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 다음과 같이 중괄호 {}블록 내용이 비어있는 기본 생성자를 바이트 코드에 자동 추가시킨다. 
6.7.2 생성자 선언
생성자는 메소드와 비슷한 모양을 가지고 있으나 리턴 타입이 없고 클래스 이름과 동일하다. 매개 변수 선언은 생략할 수도 있고 여러 개를 선언해도 좋다. 매개 변수 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.
6.7.3 필드 초기화
클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다. 만약 다른 값으로 초기화를 하고 싶다면 두가지 방법이 있다.
1.	필드를 선언할 때 초기값을 주는 방법
2.	생성자에서 초기값을 주는 방법.
생성자의 매개 변수의 이름은 초기화 시킬 필드이름과 비슷하거나 동일한 이름을 사용할 것을 권한다. 관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용하는데 이 경우 필드와 매개 변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근 불가능. 따라서 필드 앞에 this. 을 붙인다. This 는 객체 자신의 참조이다.
6.7.4 생성자 오버로딩
외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다. 따라서 자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공하는데 생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.
생성자가 오버로딩되어 있을 경우 new연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에의해 호출될생성자가 결정된다.
6.7.5 다른 생성자 호출
생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드 발생할 수 있다. 따라서 생성자에서 다른 생성자를 호출할 때에는 다음과 같이 this()코드를 사용한다
Ex) 클래스 ( [매개변수선언, …]){
This( 매개변수,...,값,…);
실행문;}
★6.8메소드
메소드는 객체의 동작에 해당하는 중괄호 {}블록을 말한다, 중괄호 블록은 이름을 가지는데 이것이 메소드 이름이다.메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.메소드는 객체 간의 데이터 전달의 수단으로 사용되고 외부로부터 매개 값을 받을 수도 있고 실행 후 어떤 값을 리턴 할 수도 있다.
6.8.1 메소드 선언
메소드 선언은 선언부(리턴타입,메소드이름,매개변수선언)와 실행 블록으로 구성된다, 메소드 선언부를 메소드 시그니쳐 라고도 한다
리턴타입- 메소드가 실행 후 리턴하는 값의 타입
리턴값이 없는 메소드는 리턴 타입에 void가 와야하며 리턴값이 있는 메소드는 리턴값의 타입이 와야한다.
메소드 이름
1 숫자로 시작하면 안되고 특수문자 사용금지
2 관례적으로 메소드명은 소문자로 작성
3 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫머리 글자는 대문자로
매개 변수 언언
매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다,
매개 변수의 수를 모를 경우 
매개 변수를 배열 타입으로 선언하는 것이다.
6.8.2 리턴 문
리턴값이 있는 메소드
메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야함.
리턴문은 사용할 때 주의할 은 리턴 문 이후에 실행문이 오면 unreachable code라는 컴파일 오류가 생긴다. 
리턴값이 없는 메소드(void)
Void로 선언된 리턴값이 없는 메소드에서도 return문을 사용가능 return문을 사용하면 메소드 실행을 강제 종료 시킨다.
6.83 메소드 호출
클래스 외부에서 호출할 경우 우선 클래스로부터 객체를 생성한 뒤 참조 변수를 이용해서 메소드를 호출해야한다, 그 이유는 객체가 존재해야 메소드도 존재하기 때문
6.8.4 메소드 오버로딩 
클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩이라고 한다,
7.1 상속
객체 지향 프로그램에서도 부모 클래스의 멤버를 자식클래스에게 물려줄 수 있다.프로그램에서는 부모 클래스를 상위 클래스라고 부르기도 하고 자식클래스를 하위클래스 또는 파생클래스라고 부른다.
상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다. 상속을 해도 부모 클래스의 모든 필드와 메소드를 물려받는 것은 아니다. 부모클래스의 private접근 제한을 갖는 필드와 메소드는 상속대상에서 제외된다. 그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 dafault접근제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.
7.2 클래스 상속
자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 선택된 부모 클래스는 다음 과 같이 extends 뒤에 기술
Ex) class 자식ㄴ클래스 extends 부모클래스{필드,생성자,메소드}
다중상속은 허용x
7.3 부모 생성자 호출 
자바에서는 자식 객체를 생성하면 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.모든 객체는 클래스의 생성자를 호출해야만 생성된다, 부모 객체도 예외x
7.4 메소드 재정의
부모클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다, 이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다. 자바는 이런 경우를 위해 메소드 오버라이딩 기능을 제공한다
7.4.1
메소드 재정의
메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우 자식 클래스에서 동일한 method를 재정의하는 것을 말한다,
오버라이딩 시
1.부모의 메소드와 동일한 시그니쳐( 리턴타입, 메소드 이름.매개 변수 리스트)를 가져야 한다
2. 접근 제한을 더 강하게 오버라이딩할 수 없다.
3.새로운 예외를 throws할 수 없다
이클립스는 부모 메소드 중 하나를 선택해서 오버라이딩 메소드를 자동 생성해주는 기능이 있다.
이 기능은 부모 메소드의 시그니처를 정확히 모를 경우 매우 유용하게 사용 가능
1.	자식 클래스에서 오버라이딩메소드를 작성할 위치로 입력커서를 옮긴다.
2.	메뉴에서[source->override/implement methods]를 선택
3.	부모 클래스에서 오버라이딩될 메소드를 선택하고 ok버튼 클릭
7.4.2 부모 메소드 호출(super)
자식클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super키워드를 붙여서 부모 메소드를 호출할 수 있다. Super는 부모 객체를 참조하고 있기 떄문에 부모 메소드에 직접 접근 가능,
7.5 final 클래스와 final 메소드
•	final 키워드는 클래스, 필드, 메소드 선언 시 사용 가능하며, 해당 선언이 최종 상태이고 결코 수정될 수 없음을 뜻한다.
•	클래스와 메소드에 final 키워드가 지정되면 상속과 관련이 있다.
•	final 키워드를 클래스 앞에 붙이게 되면 최종적인 클래스가 되므로 상속할 수 없는 클래스가 된다. 자식 클래스를 만들 수 없는 것이다. 대표적인 예로 String 클래스가 있다.
•	메소드 선언시 final 키워드를 붙이면 최종적인 메소드가 되므로 오버라이딩을 할 수 없는 메소드가 된다. 자식 클래스에서 재정의할 수 없다는 것이다.
7.6 proteted 접근 제한자
protcted는 필드와 생성자, 메소드 선언에 사용될 수 있는데, 같은 패키지에서는 접근 제한이 없으나 다른 패키지에서는 자식 클래스만 접근을 허용한다.
new 연산자를 통해 생성자를 직접 호출하는 것이 아닌, 자식 생성자에서 super로 호출해야 한다.

7.7 타입 변환과 다형성
다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 자바는 다형성을 위해 부모 타입에 모든 자식 객체가 대입될 수 있도록 했다. 이것을 이용하면 객체는 부품화가 가능하다.
자식 타입은 부모 타입으로 자동 타입 변환 이 가능하다.
7.7.1 자동 타입 변환(promotion)
자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다. ex) 동물-고양이
Cat cat = new Cat();
Animal animal = cat; //Annimal animal = new Cat()도 가능하다.
위 코드로 생성되는 메모리 상태를 보면, cat과 animal은 동일한 cat 객체를 참조한다.
부모 클래스로 타입은 변해도, 참조하는 객체는 같다. ==연산 시 true를 산출한다.
부모 타입으로 자동 변환 이후 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정된다. 다만 자식 클래스에서 오버라이딩된 메소드는 호출 가능하다.
7.7.2 필드의 다형성
이러한 자동 타입 변환이 필요한 까닭은, 다형성을 구현하는 기술적 방법 때문이다.
다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질을 뜻한다.
주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현하는데, 필드의 타입은 변함이 없지만, 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라질 수 있다. 이것이 필드의 다형성이다.
7.7.3 하나의 배열로 객체 관리
객체들을 배열을 통하여 관리하면, 코드를 보다 깔끔하게 만들 수 있다.
public class Body{
    Hand[] hands = {
        new Hand();
        new Hand();
    };
}//Body 클래스 -> 반복문을 이용하여 hands를 사용할 수 있다.
7.7.4 매개 변수의 다형성
자동 타입 변환은 필드의 값보다 메소드를 호출할 때 많이 발생한다.
메소드를 호출할 때 매개 변수에 자식 타입 객체를 지정함으로써 매개 변수의 다형성을 높일 수 있다.
class Driver{
    void drive(Vehicle vihicle){
        vehicle.run();
    }
}
을 정상적으로 호출하면

Driver driver = new Driver();
Vehicle vehicle = new Vehicle();
driver.drive(vehicle);
이지만, Vehicle의 자식 클래스인 Bus나 Taxi 객체를 매개값으로 넘겨줄 수도 있는 것이다. 이로써 메소드의 실행 결과가 다양해진다.
7.7.5 강제 타입 변환
강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말하는데, 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때에 사용할 수 있다.
이는 부모 타입으로 자동 변환된 자식 타입의 메소드와 필드를 다시 사용하고자 할 때 사용할 수 있다.
자식클래스 변수 = (자식클래스) 부모클래스 타입;//자동 변환된 상태
